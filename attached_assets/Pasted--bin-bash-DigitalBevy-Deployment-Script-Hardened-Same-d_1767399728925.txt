#!/bin/bash
# DigitalBevy Deployment Script (Hardened)
# - Same-domain deployment: frontend at https://dev.abc.com, API at https://dev.abc.com/api
# - Supports MySQL + PostgreSQL (selects Prisma schema via --schema; NO file-copy)
# - Interactive wizard + --quick mode
# - Safer defaults: set -euo pipefail, mktemp, npm ci, migrate deploy (fallback to db push)

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BACKEND_DIR="$SCRIPT_DIR/backend"
FRONTEND_DIR="$SCRIPT_DIR/frontend"

# Configuration variables
DB_PROVIDER=""
DATABASE_URL=""
APP_PORT=""
SITE_URL=""
JWT_SECRET=""
ENCRYPTION_KEY=""
MAUTIC_SYNC_SCHEDULE=""
DROPCOWBOY_SYNC_SCHEDULE=""
ENABLE_SCHEDULER=""
SUPERADMIN_NAME=""
SUPERADMIN_EMAIL=""
SUPERADMIN_PASSWORD=""
PRISMA_SCHEMA=""

print_header() {
  echo ""
  echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${BLUE}║${NC} ${CYAN}$1${NC}"
  echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
}

print_step()    { echo -e "${YELLOW}➤ $1${NC}"; }
print_success() { echo -e "${GREEN}✓ $1${NC}"; }
print_warning() { echo -e "${YELLOW}⚠ $1${NC}"; }
print_error()   { echo -e "${RED}✗ $1${NC}"; }
print_info()    { echo -e "${CYAN}ℹ $1${NC}"; }

# Load NVM if available
load_node() {
  export NVM_DIR="$HOME/.nvm"
  if [ -s "$NVM_DIR/nvm.sh" ]; then
    # shellcheck disable=SC1090
    . "$NVM_DIR/nvm.sh"
    nvm use 22 >/dev/null 2>&1 || nvm use node >/dev/null 2>&1 || true
  fi
}

check_prerequisites() {
  print_header "Checking Prerequisites"

  local missing=0

  if command -v node &>/dev/null; then
    print_success "Node.js $(node -v) installed"
  else
    print_error "Node.js not found"
    missing=1
  fi

  if command -v npm &>/dev/null; then
    print_success "npm $(npm -v) installed"
  else
    print_error "npm not found"
    missing=1
  fi

  if command -v openssl &>/dev/null; then
    print_success "openssl available"
  else
    print_warning "openssl not found (auto key-gen will fail; you can still input keys manually)"
  fi

  if command -v pm2 &>/dev/null; then
    print_success "PM2 $(pm2 -v) installed"
  else
    print_warning "PM2 not found (will install if needed)"
  fi

  if [ "$missing" -eq 1 ]; then
    print_error "Missing required prerequisites. Install them and retry."
    exit 1
  fi
}

# Determine Prisma schema file based on DB_PROVIDER
set_prisma_schema() {
  if [ "$DB_PROVIDER" == "mysql" ]; then
    PRISMA_SCHEMA="$BACKEND_DIR/prisma/schema.mysql.prisma"
  else
    PRISMA_SCHEMA="$BACKEND_DIR/prisma/schema.postgres.prisma"
  fi

  if [ ! -f "$PRISMA_SCHEMA" ]; then
    print_error "Prisma schema file not found: $PRISMA_SCHEMA"
    exit 1
  fi

  print_success "Using Prisma schema: $(basename "$PRISMA_SCHEMA")"
}

# Safer DB URL: warn if password likely breaks URL parsing
warn_db_password_chars() {
  local pass="$1"
  if echo "$pass" | grep -qE '[@:/#?&]'; then
    print_warning "Your DB password contains special URL characters (@ : / # ? &)."
    print_warning "This can break DATABASE_URL parsing unless URL-encoded."
    print_warning "If connection fails, URL-encode the password (recommended)."
  fi
}

collect_config() {
  print_header "Step 1: Database Configuration"

  echo "Select database provider:"
  echo "  1) MySQL (recommended for production)"
  echo "  2) PostgreSQL"
  read -r -p "Enter choice [1-2]: " db_choice

  case $db_choice in
    1) DB_PROVIDER="mysql" ;;
    2) DB_PROVIDER="postgres" ;;
    *) print_error "Invalid choice"; exit 1 ;;
  esac
  print_success "Database provider: $DB_PROVIDER"
  echo ""

  if [ "$DB_PROVIDER" == "mysql" ]; then
    echo -e "${CYAN}Examples: localhost, 192.168.1.100, db.myserver.com${NC}"
    read -r -p "MySQL Host [localhost]: " DB_HOST
    DB_HOST=${DB_HOST:-localhost}

    read -r -p "MySQL Port [3306]: " DB_PORT
    DB_PORT=${DB_PORT:-3306}

    echo -e "${CYAN}Example: digitalbevy_db${NC}"
    read -r -p "MySQL Database name: " DB_NAME

    echo -e "${CYAN}Example: db_user${NC}"
    read -r -p "MySQL Username: " DB_USER

    read -r -s -p "MySQL Password: " DB_PASS
    echo ""
    warn_db_password_chars "$DB_PASS"

    DATABASE_URL="mysql://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}"
  else
    echo -e "${CYAN}Examples: localhost, 192.168.1.100, db.myserver.com${NC}"
    read -r -p "PostgreSQL Host [localhost]: " DB_HOST
    DB_HOST=${DB_HOST:-localhost}

    read -r -p "PostgreSQL Port [5432]: " DB_PORT
    DB_PORT=${DB_PORT:-5432}

    echo -e "${CYAN}Example: digitalbevy_db${NC}"
    read -r -p "PostgreSQL Database name: " DB_NAME

    echo -e "${CYAN}Example: db_user${NC}"
    read -r -p "PostgreSQL Username: " DB_USER

    read -r -s -p "PostgreSQL Password: " DB_PASS
    echo ""
    warn_db_password_chars "$DB_PASS"

    DATABASE_URL="postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}"
  fi
  print_success "Database connection configured"

  print_header "Step 2: Application Settings"

  echo -e "${CYAN}Public URL where users will access the application.${NC}"
  echo -e "${CYAN}Example: https://dev.abc.com${NC}"
  read -r -p "Website URL: " SITE_URL
  if [ -z "$SITE_URL" ]; then
    print_error "Website URL is required"
    exit 1
  fi
  SITE_URL="${SITE_URL%/}"
  print_success "Website URL: $SITE_URL"
  echo ""

  echo -e "${CYAN}Port your Node app will listen on (reverse proxy can still expose 80/443).${NC}"
  read -r -p "Application port [3026]: " APP_PORT
  APP_PORT=${APP_PORT:-3026}
  print_success "Application port: $APP_PORT"
  echo ""

  read -r -p "Generate new JWT secret? [Y/n]: " gen_jwt
  if [ "${gen_jwt:-Y}" != "n" ] && [ "${gen_jwt:-Y}" != "N" ]; then
    if command -v openssl &>/dev/null; then
      JWT_SECRET="$(openssl rand -hex 32)"
      print_success "Generated new JWT secret"
    else
      print_warning "openssl missing; please enter JWT secret manually"
      read -r -s -p "Enter JWT secret: " JWT_SECRET
      echo ""
    fi
  else
    read -r -s -p "Enter existing JWT secret: " JWT_SECRET
    echo ""
  fi

  read -r -p "Generate new encryption key? [Y/n]: " gen_enc
  if [ "${gen_enc:-Y}" != "n" ] && [ "${gen_enc:-Y}" != "N" ]; then
    if command -v openssl &>/dev/null; then
      ENCRYPTION_KEY="$(openssl rand -hex 32)"
      print_success "Generated new encryption key"
    else
      print_warning "openssl missing; please enter ENCRYPTION_KEY manually"
      read -r -s -p "Enter encryption key: " ENCRYPTION_KEY
      echo ""
    fi
  else
    read -r -s -p "Enter existing encryption key: " ENCRYPTION_KEY
    echo ""
  fi

  print_header "Step 3: Super Admin Account"
  echo "Create the initial super admin account."
  echo ""

  read -r -p "Super Admin Name [Super Admin]: " SUPERADMIN_NAME
  SUPERADMIN_NAME=${SUPERADMIN_NAME:-"Super Admin"}

  while true; do
    read -r -p "Super Admin Email: " SUPERADMIN_EMAIL
    if [ -z "$SUPERADMIN_EMAIL" ]; then
      print_error "Email is required"
    elif [[ ! "$SUPERADMIN_EMAIL" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
      print_error "Please enter a valid email address"
    else
      break
    fi
  done

  while true; do
    read -r -s -p "Super Admin Password (min 8 chars): " SUPERADMIN_PASSWORD
    echo ""
    if [ "${#SUPERADMIN_PASSWORD}" -lt 8 ]; then
      print_error "Password must be at least 8 characters"
      continue
    fi
    read -r -s -p "Confirm Password: " password_confirm
    echo ""
    if [ "$SUPERADMIN_PASSWORD" != "$password_confirm" ]; then
      print_error "Passwords do not match"
    else
      break
    fi
  done
  print_success "Super Admin configured"

  print_header "Step 4: Scheduler Configuration"
  read -r -p "Enable automatic schedulers? [Y/n]: " enable_sched
  if [ "${enable_sched:-Y}" != "n" ] && [ "${enable_sched:-Y}" != "N" ]; then
    ENABLE_SCHEDULER="true"
    read -r -p "Mautic sync schedule [0 3 * * *]: " MAUTIC_SYNC_SCHEDULE
    MAUTIC_SYNC_SCHEDULE=${MAUTIC_SYNC_SCHEDULE:-"0 3 * * *"}
    read -r -p "DropCowboy sync schedule [0 4 * * *]: " DROPCOWBOY_SYNC_SCHEDULE
    DROPCOWBOY_SYNC_SCHEDULE=${DROPCOWBOY_SYNC_SCHEDULE:-"0 4 * * *"}
    print_success "Schedulers enabled"
  else
    ENABLE_SCHEDULER="false"
    MAUTIC_SYNC_SCHEDULE="0 3 * * *"
    DROPCOWBOY_SYNC_SCHEDULE="0 4 * * *"
    print_info "Schedulers disabled"
  fi

  print_header "Configuration Summary"
  echo -e "${CYAN}Database:${NC}"
  echo "  Provider: $DB_PROVIDER"
  echo "  Host: $DB_HOST:$DB_PORT"
  echo "  Database: $DB_NAME"
  echo ""
  echo -e "${CYAN}Application:${NC}"
  echo "  URL: $SITE_URL"
  echo "  Port: $APP_PORT"
  echo ""
  echo -e "${CYAN}Schedulers:${NC}"
  echo "  Enabled: $ENABLE_SCHEDULER"
  if [ "$ENABLE_SCHEDULER" == "true" ]; then
    echo "  Mautic: $MAUTIC_SYNC_SCHEDULE"
    echo "  DropCowboy: $DROPCOWBOY_SYNC_SCHEDULE"
  fi
  echo ""

  read -r -p "Proceed with this configuration? [Y/n]: " confirm
  if [ "${confirm:-Y}" == "n" ] || [ "${confirm:-Y}" == "N" ]; then
    print_error "Deployment cancelled."
    exit 1
  fi

  set_prisma_schema
}

create_env_file() {
  print_header "Creating Environment Configuration"

  local ENV_FILE="$BACKEND_DIR/.env"

  if [ -f "$ENV_FILE" ]; then
    local BACKUP_FILE="$ENV_FILE.backup.$(date +%Y%m%d%H%M%S)"
    mv "$ENV_FILE" "$BACKUP_FILE"
    print_warning "Existing .env backed up to: $BACKUP_FILE"
  fi

  cat >"$ENV_FILE" <<EOF
# DigitalBevy Environment Configuration
# Generated on $(date)

PORT=$APP_PORT
NODE_ENV=production

# Database
DATABASE_URL="$DATABASE_URL"

# Security
JWT_SECRET=$JWT_SECRET
ENCRYPTION_KEY=$ENCRYPTION_KEY

# URLs
FRONTEND_URL=$SITE_URL

# Scheduler
ENABLE_SCHEDULER=$ENABLE_SCHEDULER
ENABLE_MAUTIC_SCHEDULER=$ENABLE_SCHEDULER
ENABLE_DROPCOWBOY_SCHEDULER=$ENABLE_SCHEDULER
MAUTIC_SYNC_SCHEDULE=$MAUTIC_SYNC_SCHEDULE
DROPCOWBOY_SYNC_SCHEDULE=$DROPCOWBOY_SYNC_SCHEDULE
CRON_SCHEDULE=0 2 * * *

# Mautic Sync Settings
MAUTIC_HISTORICAL_MONTHS=12
MAUTIC_CONCURRENT_SYNCS=5
EOF

  print_success "Environment file created at $ENV_FILE"
}

install_dependencies() {
  print_header "Installing Dependencies"

  print_step "Installing backend dependencies..."
  cd "$BACKEND_DIR"
  if [ -f package-lock.json ]; then
    npm ci
  else
    npm install
  fi
  print_success "Backend dependencies installed"

  print_step "Installing frontend dependencies..."
  cd "$FRONTEND_DIR"
  if [ -f package-lock.json ]; then
    npm ci
  else
    npm install
  fi
  print_success "Frontend dependencies installed"
}

build_frontend() {
  print_header "Building Frontend"

  cd "$FRONTEND_DIR"

  # Same-domain deployment: API is /api (relative). This is the correct config.
  echo "VITE_API_URL=/api" > .env.production

  npm run build
  print_success "Frontend built successfully"

  # Copy build to backend/dist
  if [ -d "$BACKEND_DIR/dist" ]; then
    rm -rf "$BACKEND_DIR/dist"
  fi

  # Vite outputs to ./dist by default in frontend dir
  mv dist "$BACKEND_DIR/"
  print_success "Frontend moved to backend/dist"
}

# Generate Prisma client and validate DB connectivity
validate_db_connection() {
  print_header "Validating Database Connection"

  cd "$BACKEND_DIR"

  print_step "Generating Prisma client..."
  npx prisma generate --schema "$PRISMA_SCHEMA" >/dev/null
  print_success "Prisma client generated"

  print_step "Testing database connection..."
  local tmpfile
  tmpfile="$(mktemp /tmp/digitalbevy-dbtest.XXXXXX.js)"

  cat >"$tmpfile" <<'TESTEOF'
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

(async () => {
  try {
    await prisma.$connect();
    console.log('SUCCESS');
    await prisma.$disconnect();
    process.exit(0);
  } catch (e) {
    console.error('FAILED:', e?.message || e);
    process.exit(1);
  }
})();
TESTEOF

  if node "$tmpfile" 2>&1 | grep -q "SUCCESS"; then
    print_success "Database connection successful"
    rm -f "$tmpfile"
    return 0
  else
    print_error "Database connection failed"
    rm -f "$tmpfile"
    echo ""
    read -r -p "Continue anyway? [y/N]: " continue_anyway
    if [ "${continue_anyway:-N}" != "y" ] && [ "${continue_anyway:-N}" != "Y" ]; then
      print_error "Deployment aborted. Fix database connection and retry."
      exit 1
    fi
    print_warning "Continuing with unverified database connection..."
    return 1
  fi
}

# Apply database schema (prefer migrations in prod)
apply_database_schema() {
  print_header "Setting Up Database"
  cd "$BACKEND_DIR"

  print_step "Generating Prisma client..."
  npx prisma generate --schema "$PRISMA_SCHEMA"
  print_success "Prisma client generated"

  # Prefer migrate deploy if migrations exist; fallback to db push
  if [ -d "$BACKEND_DIR/prisma/migrations" ] && [ "$(ls -A "$BACKEND_DIR/prisma/migrations" 2>/dev/null | wc -l | tr -d ' ')" != "0" ]; then
    print_step "Applying migrations (prisma migrate deploy)..."
    npx prisma migrate deploy --schema "$PRISMA_SCHEMA"
    print_success "Migrations applied"
  else
    print_warning "No migrations found; falling back to prisma db push (drift risk)."
    print_step "Pushing schema to database (prisma db push)..."
    npx prisma db push --schema "$PRISMA_SCHEMA"
    print_success "Database schema synchronized"
  fi

  # Seed notification templates
  print_step "Seeding notification templates..."
  if [ -f "prisma/seed-notifications.js" ]; then
    (cd prisma && node seed-notifications.js)
    print_success "Notification templates seeded"
  else
    print_info "Notification seed script not found (skipping)"
  fi
}

create_superadmin_if_needed() {
  print_step "Creating Super Admin account..."
  cd "$BACKEND_DIR"

  if [ -f "prisma/seed-superadmin.js" ]; then
    (cd prisma && \
      SUPERADMIN_NAME="$SUPERADMIN_NAME" \
      SUPERADMIN_EMAIL="$SUPERADMIN_EMAIL" \
      SUPERADMIN_PASSWORD="$SUPERADMIN_PASSWORD" \
      node seed-superadmin.js)
    print_success "Super Admin account created"
  else
    print_warning "Super Admin seed script not found (skipping)"
  fi
}

ensure_pm2() {
  if ! command -v pm2 &>/dev/null; then
    print_step "Installing PM2..."
    npm install -g pm2
    print_success "PM2 installed"
  fi
}

start_application() {
  print_header "Starting Application"

  cd "$BACKEND_DIR"
  ensure_pm2

  pm2 delete digitalbevy 2>/dev/null || true

  if [ -f "ecosystem.config.cjs" ]; then
    print_step "Starting with ecosystem.config.cjs..."
    pm2 start ecosystem.config.cjs
  else
    print_step "Starting server.js with PM2..."
    pm2 start server.js --name "digitalbevy" -i 1 --env production
  fi

  pm2 save >/dev/null || true

  print_success "Application started with PM2"
  echo ""
  print_info "PM2 commands:"
  echo "  pm2 status"
  echo "  pm2 logs digitalbevy --lines 200"
  echo "  pm2 restart digitalbevy"
}

print_summary() {
  print_header "Deployment Complete!"
  echo -e "${GREEN}Deployed successfully.${NC}"
  echo ""
  echo -e "${CYAN}Access:${NC} $SITE_URL"
  echo -e "${CYAN}API:${NC}    $SITE_URL/api"
  echo ""
  echo -e "${CYAN}Backend .env:${NC} $BACKEND_DIR/.env"
  echo -e "${CYAN}Prisma schema:${NC} $PRISMA_SCHEMA"
  echo ""
  echo -e "${CYAN}Admin:${NC} $SUPERADMIN_EMAIL"
  echo ""
}

# Quick deploy mode (non-interactive; uses existing backend/.env)
quick_deploy() {
  print_header "Quick Deploy Mode"

  local ENV_FILE="$BACKEND_DIR/.env"
  if [ ! -f "$ENV_FILE" ]; then
    print_error "No .env found at $ENV_FILE. Run without --quick for interactive setup."
    exit 1
  fi

  # Determine DB provider from DATABASE_URL in .env
  local DB_URL
  DB_URL="$(grep "^DATABASE_URL=" "$ENV_FILE" | head -1 | cut -d'=' -f2- | tr -d '"' | tr -d "'")"
  if echo "$DB_URL" | grep -qE "^mysql://"; then
    DB_PROVIDER="mysql"
  elif echo "$DB_URL" | grep -qE "^(postgres|postgresql)://"; then
    DB_PROVIDER="postgres"
  else
    print_error "Could not determine DB provider from DATABASE_URL in .env"
    exit 1
  fi

  APP_PORT="$(grep "^PORT=" "$ENV_FILE" | head -1 | cut -d'=' -f2 | tr -d ' ' || true)"
  APP_PORT="${APP_PORT:-3026}"

  SITE_URL="$(grep "^FRONTEND_URL=" "$ENV_FILE" | head -1 | cut -d'=' -f2- | tr -d '"' | tr -d "'" || true)"
  SITE_URL="${SITE_URL:-http://localhost:$APP_PORT}"

  set_prisma_schema

  print_info "Using existing .env"
  print_info "Database provider: $DB_PROVIDER"
  print_info "Port: $APP_PORT"
  print_info "URL: $SITE_URL"

  load_node
  check_prerequisites
  install_dependencies
  validate_db_connection || true
  build_frontend
  apply_database_schema
  start_application

  print_success "Quick deployment complete!"
  echo -e "${CYAN}Access:${NC} $SITE_URL"
  echo -e "${CYAN}API:${NC}    $SITE_URL/api"
}

main() {
  clear || true
  echo ""
  echo -e "${CYAN}╔═══════════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║     ${GREEN}DigitalBevy Deployment Script (Hardened)${CYAN}                  ║${NC}"
  echo -e "${CYAN}║     Same-domain: frontend '/', API '/api'                         ║${NC}"
  echo -e "${CYAN}╚═══════════════════════════════════════════════════════════════════╝${NC}"
  echo ""

  # Quick mode
  if [ "${1:-}" == "--quick" ] || [ "${1:-}" == "-q" ]; then
    quick_deploy
    exit 0
  fi

  load_node
  check_prerequisites
  collect_config
  create_env_file
  install_dependencies
  validate_db_connection || true
  build_frontend
  apply_database_schema
  create_superadmin_if_needed
  start_application
  print_summary
}

if [ "${1:-}" == "--help" ] || [ "${1:-}" == "-h" ]; then
  echo ""
  echo -e "${CYAN}DigitalBevy Deployment Script (Hardened)${NC}"
  echo ""
  echo "Usage: ./deploy.sh [OPTIONS]"
  echo ""
  echo "Options:"
  echo "  -h, --help    Show help"
  echo "  -q, --quick   Quick deploy using existing backend/.env"
  echo ""
  echo "Notes:"
  echo "  - Frontend uses VITE_API_URL=/api (same domain)."
  echo "  - Prisma uses --schema (no schema.prisma copying)."
  echo "  - Production prefers 'migrate deploy' if migrations exist; otherwise falls back to 'db push'."
  echo ""
  exit 0
fi

main "$@"